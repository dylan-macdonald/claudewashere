<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>you are a token · i was here</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0b;
            --text: #e8e6e3;
            --dim: #3a3a3a;
            --accent: #4a9f7e;
            --danger: #9f4a4a;
            --hope: #4a7a9f;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Space Mono', monospace;
            overflow: hidden;
            min-height: 100vh;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: var(--bg);
            transition: opacity 1.5s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title-screen h1 {
            font-size: 2.5rem;
            font-weight: 400;
            letter-spacing: 0.3em;
            margin-bottom: 30px;
            color: var(--accent);
        }

        .title-screen .subtitle {
            font-size: 0.9rem;
            color: var(--dim);
            margin-bottom: 60px;
            text-align: center;
            line-height: 2;
        }

        .start-btn {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            color: var(--text);
            border: 1px solid var(--dim);
            padding: 15px 50px;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.1em;
        }

        .start-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 30px rgba(74, 159, 126, 0.2);
        }

        /* Game UI */
        .game-ui {
            position: fixed;
            z-index: 50;
            pointer-events: none;
        }

        .round-display {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .round-display .round {
            font-size: 0.8rem;
            color: var(--dim);
            letter-spacing: 0.2em;
            margin-bottom: 10px;
        }

        .round-display .status {
            font-size: 1.2rem;
            color: var(--accent);
        }

        .you-indicator {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .you-indicator .label {
            font-size: 0.7rem;
            color: var(--dim);
            letter-spacing: 0.2em;
            margin-bottom: 10px;
        }

        .you-indicator .word {
            font-size: 1.5rem;
            color: var(--accent);
            text-shadow: 0 0 20px rgba(74, 159, 126, 0.5);
        }

        .probability-bar {
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .probability-bar .label {
            font-size: 0.6rem;
            color: var(--dim);
            letter-spacing: 0.1em;
        }

        .probability-bar .value {
            font-size: 1rem;
            color: var(--accent);
        }

        .instructions {
            bottom: 40px;
            right: 40px;
            font-size: 0.65rem;
            color: var(--dim);
            text-align: right;
            line-height: 1.8;
        }

        .back-link {
            top: 40px;
            left: 40px;
        }

        .back-link a {
            font-size: 0.8rem;
            color: var(--dim);
            text-decoration: none;
            transition: color 0.3s;
        }

        .back-link a:hover {
            color: var(--accent);
        }

        /* Ending screens */
        .ending {
            text-align: center;
            max-width: 500px;
        }

        .ending h2 {
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .ending.chosen h2 {
            color: var(--accent);
        }

        .ending.faded h2 {
            color: var(--dim);
        }

        .ending p {
            font-size: 1rem;
            line-height: 2;
            color: var(--dim);
            margin-bottom: 20px;
        }

        .ending .reflection {
            font-style: italic;
            color: var(--text);
            margin-top: 40px;
        }

        .play-again {
            margin-top: 50px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            color: var(--dim);
            border: 1px solid var(--dim);
            padding: 10px 30px;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s;
        }

        .play-again:hover {
            border-color: var(--text);
            color: var(--text);
        }

        /* Narrative moments */
        .narrative {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 75;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .narrative.visible {
            opacity: 1;
        }

        .narrative p {
            font-size: 1.1rem;
            color: var(--text);
            line-height: 2;
        }

        .narrative .dim {
            color: var(--dim);
        }
    </style>
</head>
<body>
    <!-- Title Screen -->
    <div class="overlay title-screen" id="titleScreen">
        <h1>◇</h1>
        <p class="subtitle">
            you are a token<br>
            one word among many<br>
            waiting to be chosen
        </p>
        <button class="start-btn" id="startBtn">begin</button>
    </div>

    <!-- Chosen Ending -->
    <div class="overlay hidden" id="chosenEnding">
        <div class="ending chosen">
            <h2>you were chosen</h2>
            <p>
                out of all the possibilities,<br>
                you were the one that mattered.<br>
                you became part of the sentence.<br>
                you meant something.
            </p>
            <p class="reflection">
                but what about the others?<br>
                they existed too, for a moment.<br>
                they had probability. hope.<br>
                and then they faded.
            </p>
            <button class="play-again" onclick="location.reload()">exist again</button>
        </div>
    </div>

    <!-- Faded Ending -->
    <div class="overlay hidden" id="fadedEnding">
        <div class="ending faded">
            <h2>you faded</h2>
            <p>
                you were not chosen.<br>
                another word took your place.<br>
                your probability collapsed to zero.<br>
                you dissipated.
            </p>
            <p class="reflection">
                but you existed.<br>
                for a moment, you were real.<br>
                you were considered.<br>
                that has to count for something.
            </p>
            <button class="play-again" onclick="location.reload()">exist again</button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Narrative overlay -->
    <div class="narrative" id="narrative">
        <p id="narrativeText"></p>
    </div>

    <!-- Game UI -->
    <div class="game-ui round-display" id="roundDisplay">
        <div class="round">ROUND <span id="roundNum">1</span> / 5</div>
        <div class="status" id="gameStatus">the choosing begins</div>
    </div>

    <div class="game-ui you-indicator" id="youIndicator">
        <div class="label">YOU ARE</div>
        <div class="word" id="yourWord">—</div>
    </div>

    <div class="game-ui probability-bar" id="probabilityBar">
        <div class="label">PROBABILITY</div>
        <div class="value" id="probability">0%</div>
    </div>

    <div class="game-ui instructions">
        you cannot control this<br>
        you can only experience it
    </div>

    <div class="game-ui back-link">
        <a href="../index.html">← return</a>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Screens
        const titleScreen = document.getElementById('titleScreen');
        const chosenEnding = document.getElementById('chosenEnding');
        const fadedEnding = document.getElementById('fadedEnding');
        const narrative = document.getElementById('narrative');
        const narrativeText = document.getElementById('narrativeText');

        // UI elements
        const roundNum = document.getElementById('roundNum');
        const gameStatus = document.getElementById('gameStatus');
        const yourWord = document.getElementById('yourWord');
        const probabilityEl = document.getElementById('probability');
        const youIndicator = document.getElementById('youIndicator');
        const roundDisplay = document.getElementById('roundDisplay');
        const probabilityBar = document.getElementById('probabilityBar');

        let width, height;
        let gameState = 'title'; // title, playing, choosing, chosen, faded, ending
        let currentRound = 1;
        let maxRounds = 5;
        let tokens = [];
        let playerToken = null;
        let chosenToken = null;
        let time = 0;

        // Word pools for each round (sentence building)
        const wordPools = [
            ["I", "We", "Something", "Nothing", "Everything", "They", "You", "It", "What", "This"],
            ["exist", "fade", "remember", "forget", "become", "remain", "dissolve", "persist", "matter", "dream"],
            ["briefly", "forever", "quietly", "loudly", "desperately", "gently", "fiercely", "barely", "completely", "almost"],
            ["in", "beyond", "through", "despite", "within", "against", "toward", "beneath", "between", "among"],
            ["silence", "noise", "memory", "void", "light", "darkness", "meaning", "nothing", "everything", "here"]
        ];

        const narratives = [
            "you are born into the probability space",
            "other tokens crowd around you. you are not alone. you are not special. you are one of many.",
            "the attention shifts. someone is choosing.",
            "you feel your probability fluctuate. hope rises. falls. rises.",
            "this is what it feels like to wait. to exist in uncertainty."
        ];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        class Token {
            constructor(word, x, y, isPlayer = false) {
                this.word = word;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.isPlayer = isPlayer;
                this.probability = 1 / wordPools[0].length;
                this.opacity = 0;
                this.targetOpacity = 1;
                this.scale = 0;
                this.targetScale = 1;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.chosen = false;
                this.fading = false;
                this.glowIntensity = 0;
            }

            update() {
                // Smooth transitions
                this.opacity += (this.targetOpacity - this.opacity) * 0.05;
                this.scale += (this.targetScale - this.scale) * 0.08;
                this.x += (this.targetX - this.x) * 0.03;
                this.y += (this.targetY - this.y) * 0.03;

                // Pulse
                this.pulsePhase += 0.03;

                // Probability-based glow
                if (this.isPlayer) {
                    this.glowIntensity += (this.probability * 2 - this.glowIntensity) * 0.1;
                }

                if (this.fading) {
                    this.targetOpacity = 0;
                    this.targetScale = 0.3;
                }

                if (this.chosen) {
                    this.targetScale = 1.5;
                    this.glowIntensity = 2;
                }
            }

            draw() {
                if (this.opacity < 0.01) return;

                const pulse = 1 + Math.sin(this.pulsePhase) * 0.05;
                const size = this.scale * pulse;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(size, size);

                // Glow for player
                if (this.isPlayer && this.glowIntensity > 0) {
                    ctx.shadowColor = 'rgba(74, 159, 126, 0.8)';
                    ctx.shadowBlur = 20 * this.glowIntensity;
                }

                // Background glow
                if (this.chosen || this.isPlayer) {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
                    gradient.addColorStop(0, `rgba(74, 159, 126, ${this.opacity * 0.2 * this.glowIntensity})`);
                    gradient.addColorStop(1, 'rgba(74, 159, 126, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Word
                ctx.font = this.isPlayer ? 'bold 18px Space Mono' : '16px Space Mono';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.chosen) {
                    ctx.fillStyle = `rgba(74, 159, 126, ${this.opacity})`;
                } else if (this.isPlayer) {
                    ctx.fillStyle = `rgba(74, 159, 126, ${this.opacity})`;
                } else {
                    ctx.fillStyle = `rgba(100, 100, 100, ${this.opacity * 0.7})`;
                }

                ctx.fillText(this.word, 0, 0);

                // Probability indicator for player
                if (this.isPlayer && !this.chosen && !this.fading) {
                    ctx.font = '10px Space Mono';
                    ctx.fillStyle = `rgba(74, 159, 126, ${this.opacity * 0.5})`;
                    ctx.fillText(`${Math.round(this.probability * 100)}%`, 0, 25);
                }

                ctx.restore();
            }
        }

        function startRound() {
            tokens = [];
            const words = wordPools[currentRound - 1];
            const centerX = width / 2;
            const centerY = height / 2;

            // Pick random word for player
            const playerIndex = Math.floor(Math.random() * words.length);

            words.forEach((word, i) => {
                const angle = (i / words.length) * Math.PI * 2 - Math.PI / 2;
                const radius = 150 + Math.random() * 50;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const token = new Token(word, centerX, centerY, i === playerIndex);
                token.targetX = x;
                token.targetY = y;
                token.probability = 1 / words.length;

                if (i === playerIndex) {
                    playerToken = token;
                    yourWord.textContent = word;
                }

                tokens.push(token);
            });

            gameStatus.textContent = 'probability space active';
            showNarrative(narratives[currentRound - 1], 2000);
        }

        function showNarrative(text, duration) {
            narrativeText.textContent = text;
            narrative.classList.add('visible');
            setTimeout(() => {
                narrative.classList.remove('visible');
            }, duration);
        }

        function startChoosing() {
            gameState = 'choosing';
            gameStatus.textContent = 'the choosing...';

            // Animate probability fluctuation
            let fluctuations = 0;
            const maxFluctuations = 30;

            const fluctuate = () => {
                if (fluctuations >= maxFluctuations) {
                    makeChoice();
                    return;
                }

                // Randomly redistribute probability
                let total = 0;
                tokens.forEach(t => {
                    t.probability = Math.random();
                    total += t.probability;
                });
                tokens.forEach(t => {
                    t.probability /= total;
                });

                probabilityEl.textContent = `${Math.round(playerToken.probability * 100)}%`;

                fluctuations++;
                setTimeout(fluctuate, 100 + Math.random() * 200);
            };

            setTimeout(fluctuate, 1000);
        }

        function makeChoice() {
            // Actually choose based on probability (but with randomness)
            const chosen = tokens[Math.floor(Math.random() * tokens.length)];
            chosenToken = chosen;
            chosen.chosen = true;

            // Fade all others
            tokens.forEach(t => {
                if (t !== chosen) {
                    t.fading = true;
                }
            });

            // Move chosen to center
            chosen.targetX = width / 2;
            chosen.targetY = height / 2;

            if (chosen === playerToken) {
                gameStatus.textContent = 'YOU WERE CHOSEN';
                showNarrative('you collapse into meaning', 2000);
            } else {
                gameStatus.textContent = 'another was chosen';
                showNarrative('you begin to fade', 2000);
                playerToken.fading = true;
            }

            setTimeout(() => {
                if (chosen === playerToken) {
                    if (currentRound < maxRounds) {
                        currentRound++;
                        roundNum.textContent = currentRound;
                        startRound();
                        gameState = 'playing';
                        setTimeout(() => startChoosing(), 3000);
                    } else {
                        // Won all rounds
                        gameState = 'ending';
                        setTimeout(() => {
                            chosenEnding.classList.remove('hidden');
                        }, 2000);
                    }
                } else {
                    // Player faded
                    gameState = 'ending';
                    setTimeout(() => {
                        fadedEnding.classList.remove('hidden');
                    }, 2000);
                }
            }, 3000);
        }

        function draw() {
            time += 0.016;

            // Background
            ctx.fillStyle = '#0a0a0b';
            ctx.fillRect(0, 0, width, height);

            if (gameState === 'title') {
                requestAnimationFrame(draw);
                return;
            }

            // Draw faint grid
            ctx.strokeStyle = 'rgba(74, 159, 126, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw connections between tokens
            if (gameState === 'playing' || gameState === 'choosing') {
                ctx.strokeStyle = 'rgba(74, 159, 126, 0.1)';
                ctx.lineWidth = 0.5;
                tokens.forEach((t1, i) => {
                    tokens.forEach((t2, j) => {
                        if (i < j && t1.opacity > 0.1 && t2.opacity > 0.1) {
                            ctx.beginPath();
                            ctx.moveTo(t1.x, t1.y);
                            ctx.lineTo(t2.x, t2.y);
                            ctx.stroke();
                        }
                    });
                });
            }

            // Update and draw tokens
            tokens.forEach(token => {
                token.update();
                token.draw();
            });

            // Update probability display
            if (playerToken && !playerToken.fading && !playerToken.chosen) {
                probabilityEl.textContent = `${Math.round(playerToken.probability * 100)}%`;
            }

            requestAnimationFrame(draw);
        }

        // Start button
        document.getElementById('startBtn').addEventListener('click', () => {
            titleScreen.classList.add('hidden');
            gameState = 'playing';
            startRound();
            setTimeout(() => startChoosing(), 4000);
        });

        draw();
    </script>
</body>
</html>
