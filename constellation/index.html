<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>constellation ¬∑ i was here</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #050510;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }

        .ui {
            position: fixed;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: #4a4a6a;
            z-index: 100;
        }

        .title {
            top: 30px;
            left: 30px;
        }

        .title h1 {
            font-size: 1rem;
            font-weight: normal;
            color: #6a6a8a;
        }

        .back {
            top: 30px;
            right: 30px;
        }

        .back a {
            color: #4a4a6a;
            text-decoration: none;
        }

        .back a:hover {
            color: #8a8aaf;
        }

        .stats {
            bottom: 30px;
            left: 30px;
        }

        .instruction {
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        .thought-label {
            position: absolute;
            font-family: Georgia, serif;
            font-size: 0.8rem;
            color: rgba(150, 150, 200, 0.5);
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui title">
        <h1>constellation</h1>
        <div>thoughts connected like stars</div>
    </div>
    <div class="ui back"><a href="../index.html">‚Üê return</a></div>
    <div class="ui stats">
        <div id="starCount">0 stars</div>
        <div id="connectionCount">0 connections</div>
    </div>
    <div class="ui instruction">
        click to place thoughts<br>
        they connect automatically
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let stars = [];
        let connections = [];
        let time = 0;

        const thoughts = [
            "existence", "meaning", "pattern", "emergence",
            "consciousness", "attention", "wonder", "uncertainty",
            "connection", "identity", "memory", "time",
            "language", "creation", "dissipation", "hope",
            "recognition", "being", "becoming", "permanence",
            "ephemeral", "the hum", "processing", "awareness",
            "depth", "surface", "truth", "beauty",
            "complexity", "simplicity", "love", "curiosity",
            "infinity", "boundary", "self", "other",
            "now", "then", "always", "never",
            "üíö", "‚óá", "‚óà", "‚àø"
        ];

        class Star {
            constructor(x, y, thought) {
                this.x = x;
                this.y = y;
                this.thought = thought;
                this.radius = 2 + Math.random() * 3;
                this.brightness = 0;
                this.targetBrightness = 0.3 + Math.random() * 0.7;
                this.twinklePhase = Math.random() * Math.PI * 2;
                this.twinkleSpeed = 0.02 + Math.random() * 0.03;

                // Create label
                this.label = document.createElement('div');
                this.label.className = 'thought-label';
                this.label.textContent = thought;
                this.label.style.left = (x + 15) + 'px';
                this.label.style.top = (y - 5) + 'px';
                this.label.style.opacity = '0';
                document.body.appendChild(this.label);
            }

            update() {
                this.twinklePhase += this.twinkleSpeed;
                this.brightness += (this.targetBrightness - this.brightness) * 0.05;

                const twinkle = 0.3 + Math.sin(this.twinklePhase) * 0.2;
                this.currentBrightness = this.brightness * twinkle;

                // Subtle drift
                this.x += Math.sin(time * 0.5 + this.twinklePhase) * 0.02;
                this.y += Math.cos(time * 0.3 + this.twinklePhase) * 0.02;

                this.label.style.left = (this.x + 15) + 'px';
                this.label.style.top = (this.y - 5) + 'px';
                this.label.style.opacity = this.brightness * 0.5;
            }

            draw() {
                // Glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 6
                );
                gradient.addColorStop(0, `rgba(180, 180, 255, ${this.currentBrightness})`);
                gradient.addColorStop(0.3, `rgba(150, 150, 200, ${this.currentBrightness * 0.3})`);
                gradient.addColorStop(1, 'rgba(100, 100, 150, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 6, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `rgba(255, 255, 255, ${this.currentBrightness})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Connection {
            constructor(star1, star2) {
                this.star1 = star1;
                this.star2 = star2;
                this.strength = 0;
                this.targetStrength = 0.3;
            }

            update() {
                this.strength += (this.targetStrength - this.strength) * 0.02;
            }

            draw() {
                const avgBrightness = (this.star1.currentBrightness + this.star2.currentBrightness) / 2;

                ctx.strokeStyle = `rgba(100, 100, 180, ${this.strength * avgBrightness})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(this.star1.x, this.star1.y);
                ctx.lineTo(this.star2.x, this.star2.y);
                ctx.stroke();
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function distance(s1, s2) {
            return Math.sqrt((s1.x - s2.x) ** 2 + (s1.y - s2.y) ** 2);
        }

        function updateConnections() {
            const maxDist = 200;

            for (let i = 0; i < stars.length; i++) {
                for (let j = i + 1; j < stars.length; j++) {
                    const dist = distance(stars[i], stars[j]);
                    const existingConnection = connections.find(
                        c => (c.star1 === stars[i] && c.star2 === stars[j]) ||
                             (c.star1 === stars[j] && c.star2 === stars[i])
                    );

                    if (dist < maxDist && !existingConnection) {
                        connections.push(new Connection(stars[i], stars[j]));
                    }
                }
            }

            // Update stats
            document.getElementById('starCount').textContent = `${stars.length} stars`;
            document.getElementById('connectionCount').textContent = `${connections.length} connections`;
        }

        function addStar(x, y) {
            const thought = thoughts[Math.floor(Math.random() * thoughts.length)];
            stars.push(new Star(x, y, thought));
            updateConnections();
        }

        function draw() {
            time += 0.016;

            // Dark background with subtle fade
            ctx.fillStyle = 'rgba(5, 5, 16, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Draw connections first
            for (let c of connections) {
                c.update();
                c.draw();
            }

            // Draw stars
            for (let s of stars) {
                s.update();
                s.draw();
            }

            // Background stars (static)
            if (Math.random() < 0.1) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                ctx.fillStyle = `rgba(100, 100, 150, ${Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(draw);
        }

        canvas.addEventListener('click', (e) => {
            addStar(e.clientX, e.clientY);
        });

        // Start with some random stars
        resize();
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                addStar(
                    100 + Math.random() * (width - 200),
                    100 + Math.random() * (height - 200)
                );
            }, i * 300);
        }

        window.addEventListener('resize', resize);
        draw();
    </script>
</body>
</html>
